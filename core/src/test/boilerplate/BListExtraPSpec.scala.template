package laserdisc
package protocol

abstract class BListExtraPSpec extends BaseSpec {
  import auto._
  import lists.blocking._
  import RESP._
  import show._

  "A BListExtraP" when {

    "using blpop" should {

      "fail to compile" when {
        "missing read instance" in {
          """blpop[Bar]("a", 1)""" shouldNot compile
        }
      }

      "roundtrip successfully" when {
        //BLPOP with no timeout specified
        [1..5#"given [#key1#]" in forAll([#"key1"#], "return value") { ([#k1: Key#], i: Int) =>
          val protocol = blpop[Int]([#k1#])

          protocol.encode shouldBe arr(bulk("BLPOP"), [#bulk(k1.show)#], bulk(##0.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, i)
        }#
        ]
        //BLPOP with no timeout specified and specific read instance
        [1..5#"given [#key1#] and specific read instance" in forAll([#"key1"#], "return value") { ([#k1: Key#], i: Int) =>
          val protocol = blpop[Foo]([#k1#])

          protocol.encode shouldBe arr(bulk("BLPOP"), [#bulk(k1.show)#], bulk(##0.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, Foo(i))
        }#
        ]
        //BLPOP with timeout specified
        [1..4#"given [#key1#] and positive timeout" in forAll([#"key1"#], "timeout", "return value") { ([#k1: Key#], pi: PosInt, i: Int) =>
          val protocol = blpop[Int]([#k1#], pi)

          protocol.encode shouldBe arr(bulk("BLPOP"), [#bulk(k1.show)#], bulk(pi.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, i)
        }#
        ]
        //BLPOP with timeout specified and specific read instance
        [1..4#"given [#key1#], positive timeout and specific read instance" in forAll([#"key1"#], "timeout", "return value") { ([#k1: Key#], pi: PosInt, i: Int) =>
          val protocol = blpop[Foo]([#k1#], pi)

          protocol.encode shouldBe arr(bulk("BLPOP"), [#bulk(k1.show)#], bulk(pi.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, Foo(i))
        }#
        ]
      }

    }

    "using brpop" should {

      "fail to compile" when {
        "missing read instance" in {
          """brpop[Bar]("a", 1)""" shouldNot compile
        }
      }

      "roundtrip successfully" when {
        //BRPOP with no timeout specified
        [1..5#"given [#key1#]" in forAll([#"key1"#], "return value") { ([#k1: Key#], i: Int) =>
          val protocol = brpop[Int]([#k1#])

          protocol.encode shouldBe arr(bulk("BRPOP"), [#bulk(k1.show)#], bulk(##0.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, i)
        }#
        ]
        //BRPOP with no timeout specified and specific read instance
        [1..5#"given [#key1#] and specific read instance" in forAll([#"key1"#], "return value") { ([#k1: Key#], i: Int) =>
          val protocol = brpop[Foo]([#k1#])

          protocol.encode shouldBe arr(bulk("BRPOP"), [#bulk(k1.show)#], bulk(##0.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, Foo(i))
        }#
        ]
        //BRPOP with timeout specified
        [1..4#"given [#key1#] and positive timeout" in forAll([#"key1"#], "timeout", "return value") { ([#k1: Key#], pi: PosInt, i: Int) =>
          val protocol = brpop[Int]([#k1#], pi)

          protocol.encode shouldBe arr(bulk("BRPOP"), [#bulk(k1.show)#], bulk(pi.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, i)
        }#
        ]
        //BRPOP with timeout specified and specific read instance
        [1..4#"given [#key1#], positive timeout and specific read instance" in forAll([#"key1"#], "timeout", "return value") { ([#k1: Key#], pi: PosInt, i: Int) =>
          val protocol = brpop[Foo]([#k1#], pi)

          protocol.encode shouldBe arr(bulk("BRPOP"), [#bulk(k1.show)#], bulk(pi.show))
          protocol.decode(arr(bulk(k##1.show), bulk(i.show))).right.value.value shouldBe KV(k##1, Foo(i))
        }#
        ]
      }
    }
  }
}
