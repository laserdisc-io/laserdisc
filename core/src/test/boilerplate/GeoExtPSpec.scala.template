package laserdisc
package protocol

abstract class GeoExtPSpec extends BaseSpec with GeoP {
  import geos._
  import org.scalacheck.{Arbitrary, Gen}
  import org.scalacheck.Arbitrary.arbitrary

  implicit final val geoHashShow: Show[GeoHash] = Show.unsafeFromToString

  implicit final val coordinatesArbitrary: Arbitrary[Coordinates] = Arbitrary {
    for {
      lat  <- arbitrary[Latitude]
      long <- arbitrary[Longitude]
    } yield Coordinates(lat, long)
  }
  implicit final val positionArbitrary: Arbitrary[Position] = Arbitrary {
    for {
      m    <- arbitrary[Key]
      lat  <- arbitrary[Latitude]
      long <- arbitrary[Longitude]
    } yield Position(m, lat, long)
  }
  implicit final val unitArbitrary: Arbitrary[Unit] = Arbitrary(Gen.oneOf(unit.meters, unit.kilometers, unit.miles, unit.feet))

  final val position2BulkList: Position => List[Bulk] = {
    case Position(m, lat, long) => Bulk(long) :: Bulk(lat) :: Bulk(m) :: Nil
  }
  final val nonNegDoubleOptionToBulk: Option[NonNegDouble] => GenBulk = _.fold(NullBulk: GenBulk)(Bulk(_))
  final val oneOrMoreCoordinatesOptionToArr: OneOrMore[Option[Coordinates]] => GenArr = _.value.foldLeft(NilArr: GenArr) {
    case (NilArr, Some(Coordinates(lat, long))) => Arr(Arr(Bulk(long), Bulk(lat)))
    case (NilArr, None)                         => Arr(NilArr)
    case (Arr(e), Some(Coordinates(lat, long))) => Arr(e :+ Arr(Bulk(long), Bulk(lat)))
    case (Arr(e), None)                         => Arr(e :+ NilArr)
  }
  final val oneOrMoreGeoHashOptionToArr: OneOrMore[Option[GeoHash]] => GenArr = _.value.foldLeft(NilArr: GenArr) {
    case (NilArr, Some(gh)) => Arr(Bulk(gh))
    case (NilArr, None)     => Arr(NullBulk)
    case (Arr(e), Some(gh)) => Arr(e :+ Bulk(gh))
    case (Arr(e), None)     => Arr(e :+ NullBulk)
  }

  "The Geo extended protocol" when {

    "using geoadd" should {
      "roundtrip successfully" when {
        [1..4#"given key and [#position1#]" in forAll("key", [#"position1"#], "return value") { (k: Key, [#p1: Position#], nni: NonNegInt) =>
          val protocol = geoadd(k, [#p1#])

          protocol.encode shouldBe Arr(Bulk("GEOADD") :: Bulk(k) :: List([#p1#]).flatMap(position##2BulkList))
          protocol.decode(Num(nni.value.toLong)).right.value shouldBe nni
        }#
        ]
      }
    }

    "using geohash" should {

      "roundtrip successfully" when {
        [1..4#"given key and [#member1#]" in forAll("key", [#"member1"#], "return value") { (k: Key, [#m1: Key#], oghs: OneOrMore[Option[GeoHash]]) =>
          val protocol = geohash(k, [#m1#])

          protocol.encode shouldBe Arr(Bulk("GEOHASH") :: Bulk(k) :: List([#Bulk(m1)#]))
          protocol.decode(oneOrMoreGeoHashOptionToArr(oghs)).right.value shouldBe oghs.value
        }#
        ]
      }
    }

    "using geopos" should {

      "roundtrip successfully" when {
        [1..4#"given key and [#member1#]" in forAll("key", [#"member1"#], "return value") { (k: Key, [#m1: Key#], ocs: OneOrMore[Option[Coordinates]]) =>
          val protocol = geopos(k, [#m1#])

          protocol.encode shouldBe Arr(Bulk("GEOPOS") :: Bulk(k) :: List([#Bulk(m1)#]))
          protocol.decode(oneOrMoreCoordinatesOptionToArr(ocs)).right.value shouldBe ocs.value
        }#
        ]
      }
    }
  }
}
