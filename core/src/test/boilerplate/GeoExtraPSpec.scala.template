package laserdisc
package protocol

abstract class GeoExtraPSpec extends BaseSpec {
  import auto._
  import geo._
  import geos._
  import org.scalacheck.{ Arbitrary, Gen }
  import org.scalacheck.Arbitrary.arbitrary
  import show._

  implicit final val geoHashShow: Show[GeoHash] = Show.unsafeFromToString

  implicit final val coordinatesArbitrary: Arbitrary[Coordinates] = Arbitrary {
    for {
      lat  <- arbitrary[Latitude]
      long <- arbitrary[Longitude]
    } yield Coordinates(lat, long)
  }
  implicit final val positionArbitrary: Arbitrary[Position] = Arbitrary {
    for {
      m    <- arbitrary[Key]
      lat  <- arbitrary[Latitude]
      long <- arbitrary[Longitude]
    } yield Position(m, lat, long)
  }
  implicit final val unitArbitrary: Arbitrary[Unit] = Arbitrary(Gen.oneOf(unit.meters, unit.kilometers, unit.miles, unit.feet))

  final val position2BulkList: Position => List[Bulk] = {
    case Position(m, lat, long) => Bulk(long.show) :: Bulk(lat.show) :: Bulk(m.show) :: Nil
  }
  final val nonNegDoubleOptionToBulk: Option[NonNegDouble] => GenBulk = _.fold(NullBulk: GenBulk)(nnd => Bulk(nnd.show))

  final val oneOrMoreCoordinatesOptionToArr: OneOrMore[Option[Coordinates]] => GenArr = _.foldLeft(NilArr: GenArr) {
    case (NilArr, Some(Coordinates(lat, long))) => Arr(Arr(Bulk(long.show), Bulk(lat.show)))
    case (NilArr, None)                         => Arr(NilArr)
    case (Arr(e), Some(Coordinates(lat, long))) => Arr(e :+ Arr(Bulk(long.show), Bulk(lat.show)))
    case (Arr(e), None)                         => Arr(e :+ NilArr)
  }

  final val oneOrMoreGeoHashOptionToArr: OneOrMore[Option[GeoHash]] => GenArr = _.foldLeft(NilArr: GenArr) {
    case (NilArr, Some(gh)) => Arr(Bulk(gh.show))
    case (NilArr, None)     => Arr(NullBulk)
    case (Arr(e), Some(gh)) => Arr(e :+ Bulk(gh.show))
    case (Arr(e), None)     => Arr(e :+ NullBulk)
  }

  "A GeoExtraP" when {

    "using geoadd" should {

      "fail to compile" when {
        "given empty key" in {
          """geoadd("", Position("m", 0.0d, 0.0d))""" shouldNot compile
        }
        "given empty member" in {
          """geoadd("a", Position("", 0.0d, 0.0d))""" shouldNot compile
        }
        "given invalid latitude: -86.0" in {
          """geoadd("a", Position("b", -86.0d, 0.0d))""" shouldNot compile
        }
        "given invalid latitude: 86.0" in {
          """geoadd("a", Position("b", 86.0d, 0.0d))""" shouldNot compile
        }
        "given invalid longitude: -181.0" in {
          """geoadd("a", Position("b", 0.0d, -181.0d))""" shouldNot compile
        }
        "given invalid latitude: 181.0" in {
          """geoadd("a", Position("b", 0.0d, 181.0d))""" shouldNot compile
        }
      }

      "compile successfully" when {
        [1..4#"given key and [#position1#]" in forAll("key", [#"position1"#], "return value") { (k: Key, [#p1: Position#], nni: NonNegInt) =>
          val protocol = geoadd(k, [#p1#])

          protocol.encode shouldBe Arr(Bulk("GEOADD") :: Bulk(k.show) :: List([#p1#]).flatMap(position##2BulkList))
          protocol.decode(Num(nni.toLong)).right.value shouldBe nni
        }#
        ]
      }
    }

    "using geohash" should {

      "fail to compile" when {
        "given empty key" in {
          """geohash("", "m")""" shouldNot compile
        }
        "given empty member" in {
          """geohash("a", "")""" shouldNot compile
        }
      }

      "compile successfully" when {
        [1..4#"given key and [#member1#]" in forAll("key", [#"member1"#], "return value") { (k: Key, [#m1: Key#], oghs: OneOrMore[Option[GeoHash]]) =>
          val protocol = geohash(k, [#m1#])

          protocol.encode shouldBe Arr(Bulk("GEOHASH") :: Bulk(k.show) :: List([#Bulk(m1.show)#]))
          protocol.decode(oneOrMoreGeoHashOptionToArr(oghs)).right.value shouldBe oghs.value
        }#
        ]
      }
    }

    "using geopos" should {

      "fail to compile" when {
        "given empty key" in {
          """geopos("", "m")""" shouldNot compile
        }
        "given empty member" in {
          """geopos("a", "")""" shouldNot compile
        }
      }

      "compile successfully" when {
        [1..4#"given key and [#member1#]" in forAll("key", [#"member1"#], "return value") { (k: Key, [#m1: Key#], ocs: OneOrMore[Option[Coordinates]]) =>
          val protocol = geopos(k, [#m1#])

          protocol.encode shouldBe Arr(Bulk("GEOPOS") :: Bulk(k.show) :: List([#Bulk(m1.show)#]))
          protocol.decode(oneOrMoreCoordinatesOptionToArr(ocs)).right.value shouldBe ocs.value
        }#
        ]
      }
    }
  }
}
